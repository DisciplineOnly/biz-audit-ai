---
phase: 04-rate-limiting
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/functions/generate-report/index.ts
autonomous: true
requirements: [SEC-01]

must_haves:
  truths:
    - "generate-report edge function checks email-based rate limit (3/24h) before processing"
    - "generate-report edge function checks IP-based rate limit (10/24h) before processing"
    - "Rate limit check returns 429 with rateLimited:true and friendly message including approximate time hint"
    - "Same error message for both email and IP limit hits — does not reveal which triggered"
    - "Email matching is case-sensitive per user decision"
  artifacts:
    - path: "supabase/functions/generate-report/index.ts"
      provides: "Dual rate limiting guard (email + IP) using Upstash Redis"
      contains: "Ratelimit.fixedWindow"
  key_links:
    - from: "supabase/functions/generate-report/index.ts"
      to: "npm:@upstash/ratelimit"
      via: "npm: import specifier"
      pattern: "import.*Ratelimit.*npm:@upstash/ratelimit"
    - from: "supabase/functions/generate-report/index.ts"
      to: "npm:@upstash/redis"
      via: "npm: import specifier"
      pattern: "import.*Redis.*npm:@upstash/redis"
---

<objective>
Add dual-vector rate limiting (email + IP) to the generate-report edge function using Upstash Redis.

Purpose: Enforce SEC-01 — audit submissions are rate limited before any expensive Anthropic API calls or database writes happen. The rate limit guard runs at the top of the handler, returning a 429 with a friendly message if either the email (3/24h) or IP (10/24h) limit is exceeded.

**Important context:** Loading.tsx currently calls `submitAudit()` (Postgres INSERT) but does NOT call the `generate-report` edge function — that wiring is Phase 5 (Frontend Integration). This phase adds the rate limiting guard to the edge function and verifies it works via direct curl calls. Once Phase 5 wires `generate-report` into the submission flow, the rate limit guard will automatically enforce on real user traffic. The code is complete and deployed; enforcement is deferred to the wiring phase.

Output: Updated generate-report/index.ts with rate limiting guard block
</objective>

<execution_context>
@C:/Users/Emil/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Emil/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-rate-limiting/04-CONTEXT.md
@.planning/phases/04-rate-limiting/04-RESEARCH.md
@supabase/functions/generate-report/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Upstash Redis rate limiting guard to generate-report edge function</name>
  <files>supabase/functions/generate-report/index.ts</files>
  <action>
Modify the existing generate-report edge function to add a dual-vector rate limiting guard using Upstash Redis. The guard must run BEFORE any Anthropic or Supabase calls.

**Imports to add (at top of file, after existing imports):**
```typescript
import { Ratelimit } from 'npm:@upstash/ratelimit'
import { Redis } from 'npm:@upstash/redis'
```

**Add IP extraction helper (before Deno.serve):**
```typescript
function getClientIp(req: Request): string {
  const forwarded = req.headers.get('x-forwarded-for')
  if (!forwarded) return 'unknown'
  return forwarded.split(/\s*,\s*/)[0].trim()
}
```

**Inside the Deno.serve handler, AFTER `const body = await req.json()` and extraction of formState/scores/auditId, but BEFORE the Anthropic client instantiation, add the rate limit guard block:**

1. Extract contact email: `const contactEmail: string = body.formState?.step1?.email ?? 'unknown'`
2. Extract client IP: `const clientIp = getClientIp(req)`
3. Instantiate Redis client INSIDE the handler (per_worker mode requirement — see STATE.md decision from Phase 2):
   ```typescript
   const redis = new Redis({
     url: Deno.env.get('UPSTASH_REDIS_REST_URL')!,
     token: Deno.env.get('UPSTASH_REDIS_REST_TOKEN')!,
   })
   ```
4. Create two rate limiter instances:
   - Email: `Ratelimit.fixedWindow(3, '24 h')` with prefix `'bizaudit:email'`
   - IP: `Ratelimit.fixedWindow(10, '24 h')` with prefix `'bizaudit:ip'`
5. Run both checks in parallel: `Promise.all([emailRatelimit.limit(contactEmail), ipRatelimit.limit(clientIp)])`
6. If either check fails (`!emailResult.success || !ipResult.success`):
   - Calculate approximate hours remaining from `result.reset` (Unix timestamp in ms)
   - Only use reset from the FAILED check(s): `emailResult.success ? 0 : emailResult.reset` and same for IP
   - Compute `hoursRemaining = Math.ceil((resetMs - Date.now()) / (1000 * 60 * 60))`
   - Build time hint: `<= 1` → "in about 1 hour", `< 20` → "in about N hours", else → "tomorrow"
   - Return 429 with `{ rateLimited: true, message: "You've already submitted 3 audits today. Try again ${timeHint}." }`
   - Include corsHeaders in response (same as other responses in the function)
   - Use the SAME message for both email and IP limit hits — do NOT reveal which check triggered (CONTEXT.md locked decision)

**Important constraints:**
- Email matching is case-sensitive (CONTEXT.md: "John@gmail.com and john@gmail.com are treated as different emails") — pass email directly to `limit()`, do NOT lowercase it
- Limits are hardcoded (3 email / 10 IP per 24h) — no env vars or config tables
- Approximate timing only — never expose `result.reset` raw timestamp to the client
- Rate limit check happens BEFORE Anthropic API call and Supabase writes — this is the entire point (reject abuse before expensive work)
  </action>
  <verify>
1. Read the modified `supabase/functions/generate-report/index.ts` and confirm:
   - `npm:@upstash/ratelimit` and `npm:@upstash/redis` are imported
   - `getClientIp()` helper exists
   - Rate limit guard block appears BEFORE `new Anthropic()` instantiation
   - Both `emailRatelimit` and `ipRatelimit` instances use `fixedWindow`
   - 429 response includes `rateLimited: true` and friendly `message` with time hint
   - Redis/Ratelimit instantiated INSIDE the handler (not at module scope)
   - Email is NOT lowercased before passing to `limit()`
2. Run `npm run build` from project root to verify no client-side build regressions (edge function is Deno, not built by Vite, but ensures no accidental changes to src/)
  </verify>
  <done>
generate-report/index.ts contains a complete rate limiting guard block that:
- Checks email (3/24h) and IP (10/24h) using Upstash Redis fixedWindow
- Returns 429 with `{ rateLimited: true, message: "..." }` including approximate time hint
- Runs before any Anthropic or Supabase calls
- Uses case-sensitive email matching
- Does not reveal which limit was hit
  </done>
</task>

</tasks>

<verification>
- [ ] `supabase/functions/generate-report/index.ts` has Upstash imports at top
- [ ] Rate limit guard block runs before Anthropic API call
- [ ] 429 response format: `{ rateLimited: true, message: string }`
- [ ] Email passed case-sensitively to limiter
- [ ] IP extracted from x-forwarded-for header (first value)
- [ ] Redis + Ratelimit instantiated inside Deno.serve handler
- [ ] `npm run build` passes (no client-side regressions)
</verification>

<success_criteria>
The generate-report edge function code contains a complete dual-vector rate limiting guard that will enforce SEC-01 once deployed with Upstash credentials configured. Note: enforcement on real user submissions requires Phase 5 to wire the generate-report call into Loading.tsx — this plan adds the guard code and verifies it via code review and client build check.
</success_criteria>

<output>
After completion, create `.planning/phases/04-rate-limiting/04-01-SUMMARY.md`
</output>
