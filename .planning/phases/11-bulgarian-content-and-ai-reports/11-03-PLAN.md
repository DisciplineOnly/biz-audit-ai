---
phase: 11-bulgarian-content-and-ai-reports
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/functions/generate-report/index.ts
  - src/pages/Loading.tsx
autonomous: true
requirements: [AI-01, AI-02, AI-03]

must_haves:
  truths:
    - "Bulgarian user receives an AI-generated report written entirely in Bulgarian"
    - "AI report references the user's specific sub-niche in Bulgarian (e.g., 'като ВиК бизнес')"
    - "AI report for Bulgarian users recommends Bulgarian-market platforms (imot.bg, OLX.bg, etc.)"
    - "Rate-limit error displays in Bulgarian for Bulgarian users (machine-readable code from server, translated on client)"
    - "English AI reports continue to work identically to pre-Phase 11"
  artifacts:
    - path: "supabase/functions/generate-report/index.ts"
      provides: "Language-aware prompt building with separate Bulgarian prompt template, BG sub-niche labels, machine-readable rate-limit codes, MAX_TOKENS 5000"
      contains: "buildBulgarianPrompt"
    - path: "src/pages/Loading.tsx"
      provides: "Passes language param to generate-report, handles machine-readable rate-limit response codes"
      contains: "language: lang"
  key_links:
    - from: "src/pages/Loading.tsx"
      to: "supabase/functions/generate-report/index.ts"
      via: "supabase.functions.invoke('generate-report', { body: { language: lang } })"
      pattern: "language.*lang"
    - from: "supabase/functions/generate-report/index.ts"
      to: "Anthropic API"
      via: "Language-conditional prompt: buildPrompt() for EN, buildBulgarianPrompt() for BG"
      pattern: "buildBulgarianPrompt|buildPrompt"
    - from: "src/pages/Loading.tsx"
      to: "public/locales/bg/generating.json"
      via: "t('rateLimit.message') with timeHint interpolation from machine-readable response"
      pattern: "rateLimit\\.message|hoursRemaining"
---

<objective>
Make the AI report generation language-aware and internationalize rate-limit error handling, so Bulgarian users receive AI reports in Bulgarian and see translated error messages.

Purpose: Without language awareness, all AI reports are generated in English regardless of the user's language. The rate-limit error message is hardcoded in English on the server side. This plan makes the edge function language-aware and the error handling i18n-friendly.

Output: Language-aware generate-report edge function with Bulgarian prompt template, and Loading.tsx that passes language and handles machine-readable error codes.
</objective>

<execution_context>
@C:/Users/Emil/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Emil/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-bulgarian-content-and-ai-reports/11-CONTEXT.md
@.planning/phases/11-bulgarian-content-and-ai-reports/11-RESEARCH.md

# Source files
@supabase/functions/generate-report/index.ts
@src/pages/Loading.tsx
@src/hooks/useLang.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Bulgarian prompt template and language support to generate-report edge function</name>
  <files>supabase/functions/generate-report/index.ts</files>
  <action>
Modify the generate-report edge function to support language-aware report generation.

**1. Increase MAX_TOKENS:**
Change `const MAX_TOKENS = 4096` to `const MAX_TOKENS = 5000`. Bulgarian text is ~10-20% longer than English, and Haiku charges per actual output tokens, not the limit. This prevents truncation for Bulgarian reports.

**2. Add BG_SUB_NICHE_LABELS:**
Add a Bulgarian sub-niche label map alongside the existing English one (inline in the edge function — edge functions deploy independently, cannot import from frontend):

```typescript
const BG_SUB_NICHE_LABELS: Record<string, string> = {
  hvac: 'ОВК (отопление, вентилация, климатизация)',
  plumbing: 'ВиК (водоснабдяване и канализация)',
  electrical: 'Електроинсталации',
  garage_doors: 'Гаражни врати',
  pest_control: 'Дезинфекция и дезинсекция (DDD)',
  landscaping: 'Озеленяване и поддръжка на градини',
  cleaning: 'Професионално почистване',
  roofing: 'Покривни конструкции',
  painting: 'Бояджийски услуги',
  general_contracting: 'Строително предприемачество',
  construction: 'Строителство',
  interior_design: 'Интериорен дизайн',
  residential_sales: 'Жилищни продажби',
  commercial: 'Търговски имоти / Офиси',
  property_management: 'Управление на имоти',
  new_construction: 'Ново строителство',
  luxury_resort: 'Луксозни / Ваканционни имоти',
}
```

**3. Read language from request body:**
```typescript
const language: string = body.language ?? 'en'
```

**4. Select sub-niche label map by language:**
```typescript
const subNicheLabelMap = language === 'bg' ? BG_SUB_NICHE_LABELS : SUB_NICHE_LABELS
const subNicheLabel = subNicheKey ? (subNicheLabelMap[subNicheKey] ?? subNicheKey) : null
```
Note: fallback to raw key (not null) for unknown values, per STATE.md decision.

**5. Create buildBulgarianPrompt function:**
A separate function with the same interface as `buildPrompt` but producing a Bulgarian system prompt. Per CONTEXT.md:
- Use the research-provided template approach (separate template, not language flag injection)
- Formal business tone with Вие form
- Reference Bulgarian platforms (imot.bg, OLX.bg, Viber, etc.)
- Stay generic on business norms (no NRA, tax, regulation references)
- Sub-niche specificity (use Bulgarian sub-niche label in prompt)
- Business terms like CRM, KPI, ROI can remain in English

```typescript
function buildBulgarianPrompt(params: {
  niche: string
  businessName: string
  scores: AuditScores
  formState: FormState
  techFrustrations: string
  biggestChallenge: string
  subNiche?: string | null
}): { system: string; user: string } {
  // Same structure as buildPrompt but with Bulgarian system prompt
  const { niche, businessName, scores, formState, techFrustrations, biggestChallenge, subNiche } = params
  const isHS = niche === 'home_services'
  const nicheLabel = isHS ? 'бизнес в сферата на домашните услуги' : 'екип за недвижими имоти'
  const overallScore = scores.overall

  // Same gap/win/rec count logic
  let gapCount: string
  let quickWinCount: string
  let stratRecCount: string
  if (overallScore < 40) {
    gapCount = '4-5'; quickWinCount = '3'; stratRecCount = '3'
  } else if (overallScore <= 65) {
    gapCount = '3'; quickWinCount = '3'; stratRecCount = '3'
  } else {
    gapCount = '2'; quickWinCount = '2'; stratRecCount = '2'
  }

  const system = `Вие сте бизнес консултант, който изготвя персонализиран доклад от одит на бизнес операциите.

ЗАДЪЛЖИТЕЛНО: Целият отговор трябва да бъде на БЪЛГАРСКИ ЕЗИК. Използвайте формална обръщение (Вие). Бизнес термини като CRM, KPI, ROI могат да останат на английски, тъй като са международно приети.

Тон: Формален, но насърчителен бизнес стил. Авторитетен и структуриран. Карайте собственика на бизнеса да се чувства разбран и оптимистичен за възможностите.

Ограничения:
- Никога не препоръчвайте конкретни софтуерни продукти или доставчици по име. Идентифицирайте проблемите и тяхното бизнес въздействие, насочвайки към персонализирани решения и експертна консултация.
- Референцирайте индустриални стандарти с фрази като "Повечето успешни фирми във Вашата сфера..." без конкретни числа или имена на конкуренти.
- Когато препоръчвате платформи и инструменти, споменавайте първо български платформи (${isHS ? 'OLX.bg, bazar.bg, Facebook Marketplace' : 'imot.bg, imoti.net, homes.bg, OLX.bg'}), след което международни алтернативи ако е уместно.
- Всеки пропуск, бърза победа и препоръка ТРЯБВА да включва поле "cta" с персонализиран призив за действие, насочващ читателя да запише консултационен разговор. Примери: "Позволете ни да автоматизираме Вашия процес — запишете разговор", "Можем да изградим персонализирана система за Вашия екип".
- ${subNiche ? `Съобразете препоръките конкретно с ${subNiche} бизнес. Използвайте познанията си за уникалните предизвикателства и възможности в тази конкретна подниша.` : 'Съобразете препоръките с конкретния тип бизнес.'}
- НЕ споменавайте конкретни български закони, регулации, НАП или данъчни практики. Дръжте препоръките универсални.

Брой елементи спрямо общия резултат (${overallScore}/100):
- Генерирайте ${gapCount} пропуска
- Генерирайте ${quickWinCount} бързи победи
- Генерирайте ${stratRecCount} стратегически препоръки

Инструкция за JSON: Отговорете САМО с валиден JSON. Не включвайте markdown код фенсове, преамбюл или обяснения. Целият отговор трябва да може да се парсне с JSON.parse().

Задължителна JSON схема:
{
  "executiveSummary": "string (2-4 изречения, персонализиран параграф на БЪЛГАРСКИ, споменаващ бизнес името, нишата и общия резултат)",
  "gaps": [{ "title": "string", "description": "string (2-3 изречения)", "impact": "string (едно изречение)", "priority": "high|medium|low", "cta": "string" }],
  "quickWins": [{ "title": "string", "description": "string (конкретни стъпки)", "timeframe": "string", "priority": "high|medium|low", "cta": "string" }],
  "strategicRecommendations": [{ "title": "string", "description": "string", "roi": "string", "priority": "high|medium|low", "cta": "string" }]
}`

  // Reuse the same category score and form context extraction logic
  const sortedCategories = [...scores.categories].sort((a, b) => a.score - b.score)
  // ... (same formContext extraction as English buildPrompt)
  // Build user prompt in Bulgarian
  const user = `Генерирайте персонализиран доклад от бизнес одит за следния бизнес.

Бизнес: ${businessName}
Ниша: ${nicheLabel}
${subNiche ? `Подниша: ${subNiche}\n` : ''}Общ Резултат: ${overallScore}/100

Резултати по Категории (от най-слаб):
${categoryScoreLines}

Ключов Бизнес Контекст:
${formContextLines}

${techFrustrations ? `Технологични Затруднения: ${techFrustrations}` : ''}
${biggestChallenge ? `Най-голямо Предизвикателство: ${biggestChallenge}` : ''}

Генерирайте доклада сега като валиден JSON. ЦЕЛИЯТ текст в JSON стойностите трябва да бъде на БЪЛГАРСКИ ЕЗИК.`

  return { system, user }
}
```

IMPORTANT: The `buildBulgarianPrompt` function MUST include the same `formContext` extraction logic as `buildPrompt`. Do NOT duplicate — extract the form context building into a shared helper function `buildFormContext(formState, isHS)` and the category score lines into `buildCategoryScoreLines(scores)` to keep code DRY. Both `buildPrompt` and `buildBulgarianPrompt` call these helpers.

**6. Use language-conditional prompt selection in the main handler:**
```typescript
const { system, user } = language === 'bg'
  ? buildBulgarianPrompt({ niche, businessName, scores, formState, techFrustrations, biggestChallenge, subNiche: subNicheLabel })
  : buildPrompt({ niche, businessName, scores, formState, techFrustrations, biggestChallenge, subNiche: subNicheLabel })
```

**7. Convert rate-limit response to machine-readable format:**
Replace the hardcoded English rate-limit message:
```typescript
// BEFORE:
JSON.stringify({
  rateLimited: true,
  message: `You've already submitted 3 audits today. Try again ${timeHint}.`,
})

// AFTER:
JSON.stringify({
  rateLimited: true,
  code: 'RATE_LIMIT_EXCEEDED',
  hoursRemaining,
})
```
Remove the `timeHint` string construction (the `if/else if/else` that builds "in about 1 hour" etc.) — only `hoursRemaining` number is needed.
  </action>
  <verify>
Review the modified edge function for: (1) `buildBulgarianPrompt` function exists with full Bulgarian system prompt, (2) language is read from request body with 'en' default, (3) BG_SUB_NICHE_LABELS map exists, (4) rate-limit response uses `code` + `hoursRemaining` instead of `message`, (5) MAX_TOKENS is 5000, (6) form context extraction is shared between both prompt builders.
  </verify>
  <done>
- generate-report edge function reads `language` from request body (default: 'en')
- Bulgarian prompt template `buildBulgarianPrompt()` produces formal Bulgarian system+user prompts
- BG sub-niche labels map provides Bulgarian sub-niche names for the AI prompt
- MAX_TOKENS increased to 5000 for all languages
- Rate-limit response is machine-readable: `{ rateLimited, code, hoursRemaining }`
- Form context extraction is shared (DRY) between English and Bulgarian prompt builders
  </done>
</task>

<task type="auto">
  <name>Task 2: Update Loading.tsx to pass language and handle machine-readable rate-limit codes</name>
  <files>src/pages/Loading.tsx</files>
  <action>
**1. Pass language to generate-report:**
In the `callGenerateReport` function, add `language: lang` to the invoke body:
```typescript
const generateCall = supabase.functions.invoke("generate-report", {
  body: { auditId, formState: formStateRef.current, scores: scoresRef.current, language: lang },
});
```
The `lang` variable is already available from `useLang()` (line 16).

**2. Handle machine-readable rate-limit response:**
Replace the current rate-limit handling (which uses `body.message`) with localized message construction:

```typescript
if (body?.rateLimited) {
  setIsRateLimited(true);
  const hours = body.hoursRemaining ?? 24;
  let timeHint: string;
  if (hours <= 1) {
    timeHint = t('rateLimit.timeHints.oneHour');
  } else if (hours < 20) {
    timeHint = t('rateLimit.timeHints.hours', { count: hours });
  } else {
    timeHint = t('rateLimit.timeHints.tomorrow');
  }
  setRateLimitMessage(t('rateLimit.message', { timeHint }));
  return;
}
```

This requires the following keys in generating.json (added by Plan 01 in both en/ and bg/ files):
- `rateLimit.message` (with `{{timeHint}}` interpolation)
- `rateLimit.timeHints.oneHour`
- `rateLimit.timeHints.hours` (with `{{count}}` interpolation)
- `rateLimit.timeHints.tomorrow`

Plan 01 adds these keys to BOTH en/generating.json and bg/generating.json. Do NOT add them here — they will already exist when this task runs.

**3. Update the rate-limit message line:**
Change line 77 from:
```typescript
setRateLimitMessage(body.message ?? t('rateLimit.defaultMessage'));
```
To the new i18n-based construction above.
  </action>
  <verify>
Run `npm run build` to verify no TypeScript errors. Check that Loading.tsx passes `language: lang` in the generate-report invoke body. Verify the rate-limit handling constructs a localized message from `hoursRemaining` instead of using `body.message`.
  </verify>
  <done>
- Loading.tsx passes `language: lang` to generate-report edge function
- Rate-limit error handling uses machine-readable `code` + `hoursRemaining` from server
- Rate-limit message is constructed client-side using i18n keys (works in both EN and BG, keys added by Plan 01)
- Build passes
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes with no errors
2. generate-report edge function accepts `language` parameter and produces Bulgarian prompt when `language === 'bg'`
3. Rate-limit response is machine-readable (no hardcoded English strings from server)
4. Loading.tsx constructs localized rate-limit messages using i18n
5. English AI reports continue to work identically (no regression)
6. MAX_TOKENS is 5000 (prevents Bulgarian report truncation)
</verification>

<success_criteria>
- Bulgarian audit submissions produce AI reports written entirely in Bulgarian
- AI report references the user's sub-niche in Bulgarian (e.g., "като ВиК бизнес")
- AI report recommends Bulgarian platforms for BG users
- Rate-limit errors display in Bulgarian for BG users, English for EN users
- English experience unchanged
- Build passes
</success_criteria>

<output>
After completion, create `.planning/phases/11-bulgarian-content-and-ai-reports/11-03-SUMMARY.md`
</output>
