---
phase: 01-schema-and-environment
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - package-lock.json
  - .env.example
  - src/vite-env.d.ts
  - src/lib/supabase.ts
  - src/lib/submitAudit.ts
autonomous: true
requirements:
  - DATA-01
  - DATA-02
  - SEC-03
user_setup:
  - service: supabase
    why: "The Supabase client needs the project URL and publishable key to connect. These values are not committed to git — the user must create a local .env file from the .env.example template."
    env_vars:
      - name: VITE_SUPABASE_URL
        source: "Value: https://qyktrwpgfyvgdnexzcpr.supabase.co"
      - name: VITE_SUPABASE_PUBLISHABLE_KEY
        source: "Value: sb_publishable_aGBmVyDoU9Mbmlp939p1Ig_Hm9kvb0-"
    dashboard_config:
      - task: "Create .env file in project root by copying .env.example, then fill in the values listed above"
        location: "D:/Claude/BizAudit/.env (local file, gitignored, never commit)"
must_haves:
  truths:
    - "npm run build succeeds with no TypeScript errors"
    - "The Supabase client initializes from VITE_ environment variables and throws a clear error if they are missing"
    - "submitAudit() returns a UUID string on success and throws a typed Error on failure"
    - "No secret keys appear in any VITE_ environment variable — only VITE_SUPABASE_URL and VITE_SUPABASE_PUBLISHABLE_KEY"
  artifacts:
    - path: "src/lib/supabase.ts"
      provides: "Supabase client singleton"
      exports:
        - supabase
    - path: "src/lib/submitAudit.ts"
      provides: "Audit insert function"
      exports:
        - submitAudit
    - path: ".env.example"
      provides: "Environment variable template"
      contains: "VITE_SUPABASE_URL= and VITE_SUPABASE_PUBLISHABLE_KEY="
    - path: "src/vite-env.d.ts"
      provides: "TypeScript env var types"
      contains: "ImportMetaEnv interface with VITE_SUPABASE_URL and VITE_SUPABASE_PUBLISHABLE_KEY"
  key_links:
    - from: "src/lib/submitAudit.ts"
      to: "src/lib/supabase.ts"
      via: "import { supabase }"
      pattern: "import.*supabase.*from.*@/lib/supabase"
    - from: "src/lib/submitAudit.ts"
      to: "src/types/audit.ts"
      via: "import { AuditFormState, AuditScores }"
      pattern: "import.*AuditFormState.*AuditScores.*from.*@/types/audit"
    - from: "src/lib/supabase.ts"
      to: "import.meta.env"
      via: "VITE_SUPABASE_URL and VITE_SUPABASE_PUBLISHABLE_KEY"
      pattern: "import\\.meta\\.env\\.VITE_SUPABASE"
---

<objective>
Install the Supabase client library and wire the frontend to accept audit submissions. Creates the Supabase singleton, typed environment variables, the submit function, and the environment file template.

Purpose: This is the client-side half of Phase 1. Plan 01 creates the database table; this plan creates the code that talks to it. Both run in Wave 1 (parallel) because neither depends on the other — the code can be written without the table existing, and the table can be created without the client code existing.

Output: src/lib/supabase.ts (singleton), src/lib/submitAudit.ts (insert function), .env.example (template), updated src/vite-env.d.ts (typed env vars). The existing codebase is NOT modified except for vite-env.d.ts augmentation.
</objective>

<execution_context>
@C:/Users/Emil/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Emil/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-schema-and-environment/01-RESEARCH.md
@src/types/audit.ts
@src/lib/scoring.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install @supabase/supabase-js and scaffold environment files</name>
  <files>package.json, package-lock.json, .env.example, src/vite-env.d.ts</files>
  <action>
    1. Install the Supabase client:
       ```bash
       npm install @supabase/supabase-js
       ```
       This is the only new dependency needed for Phase 1. Do not install any other Supabase packages.

    2. Create `.env.example` in the project root with exactly these two lines and no others:
       ```
       VITE_SUPABASE_URL=
       VITE_SUPABASE_PUBLISHABLE_KEY=
       ```
       This file IS committed to git (it documents which vars are needed, without values).
       Do not create `.env` — the user must create that manually from `.env.example`.

    3. Verify `.gitignore` already excludes `.env`. If `.gitignore` exists and includes `.env` or `*.env`, no action needed. If `.env` is not gitignored, add a `.env` entry to `.gitignore`. Do NOT add `.env.example` to .gitignore — it must be committed.

    4. Replace the contents of `src/vite-env.d.ts` with the following to add typed env var declarations:
       ```typescript
       /// <reference types="vite/client" />

       interface ImportMetaEnv {
         readonly VITE_SUPABASE_URL: string
         readonly VITE_SUPABASE_PUBLISHABLE_KEY: string
       }

       interface ImportMeta {
         readonly env: ImportMetaEnv
       }
       ```
       This gives TypeScript autocompletion and type safety for the two allowed VITE_ variables. Adding any other VITE_ variable here requires explicit justification — no service role or secret keys permitted (SEC-03).
  </action>
  <verify>
    1. `node_modules/@supabase/supabase-js` directory exists after install
    2. `package.json` lists `@supabase/supabase-js` in `dependencies` (not `devDependencies`)
    3. `.env.example` file exists in project root with exactly two variable name lines
    4. `.gitignore` contains an entry matching `.env`
    5. `src/vite-env.d.ts` contains `VITE_SUPABASE_URL` and `VITE_SUPABASE_PUBLISHABLE_KEY` inside `ImportMetaEnv`
  </verify>
  <done>
    @supabase/supabase-js installed, .env.example committed template created, vite-env.d.ts typed for both VITE_ variables, .env gitignored.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Supabase client singleton and submitAudit function</name>
  <files>src/lib/supabase.ts, src/lib/submitAudit.ts</files>
  <action>
    1. Create `src/lib/supabase.ts` as the Supabase client singleton. Use the fail-fast pattern — throw at module load time if env vars are missing, not buried inside a user action:

       ```typescript
       import { createClient } from '@supabase/supabase-js'

       const supabaseUrl = import.meta.env.VITE_SUPABASE_URL
       const supabaseKey = import.meta.env.VITE_SUPABASE_PUBLISHABLE_KEY

       if (!supabaseUrl || !supabaseKey) {
         throw new Error(
           'Missing Supabase config. Ensure VITE_SUPABASE_URL and VITE_SUPABASE_PUBLISHABLE_KEY are set in .env'
         )
       }

       export const supabase = createClient(supabaseUrl, supabaseKey)
       ```

       Do NOT use `createClient` anywhere else in the codebase — all Supabase access goes through this singleton.

    2. Create `src/lib/submitAudit.ts` that maps `AuditFormState` and `AuditScores` to the audits table schema from Plan 01. The function must chain `.select('id').single()` on the insert — without `.select()`, supabase-js v2 returns null data and the UUID is lost (a known pitfall documented in research):

       ```typescript
       import { supabase } from '@/lib/supabase'
       import type { AuditFormState, AuditScores } from '@/types/audit'

       export async function submitAudit(
         formState: AuditFormState,
         scores: AuditScores
       ): Promise<string> {
         const { data, error } = await supabase
           .from('audits')
           .insert({
             niche: formState.niche,
             business_name: formState.step1.businessName,
             contact_name: formState.step1.contactName,
             contact_email: formState.step1.email,
             contact_phone: formState.step1.phone ?? null,
             partner_code: formState.partnerCode ?? null,
             overall_score: scores.overall,
             form_data: formState,
             scores: scores,
           })
           .select('id')
           .single()

         if (error) {
           throw new Error(`Audit submission failed: ${error.message}`)
         }

         return data.id
       }
       ```

       Column mapping rationale (matches Plan 01 table schema exactly):
       - `niche` maps to `formState.niche` (TEXT with CHECK constraint for 'home_services'|'real_estate')
       - `business_name` maps to `formState.step1.businessName` (TEXT NOT NULL)
       - `contact_name` maps to `formState.step1.contactName` (TEXT NOT NULL)
       - `contact_email` maps to `formState.step1.email` (TEXT NOT NULL)
       - `contact_phone` maps to `formState.step1.phone` with null coalescing (TEXT nullable)
       - `partner_code` maps to `formState.partnerCode` with null coalescing (TEXT nullable)
       - `overall_score` maps to `scores.overall` (INTEGER with CHECK 0-100)
       - `form_data` maps to the full `formState` object serialized as JSONB — stores all 8 steps for AI generation in Phase 2
       - `scores` maps to the full `scores` object serialized as JSONB — stores all category scores

       Note: `formState.niche` is typed as `Niche | null` in the existing types. The caller (Loading.tsx integration in Phase 5) is responsible for ensuring niche is set before calling submitAudit. This function does not guard against null niche — the Postgres CHECK constraint will reject it if somehow null reaches the DB.

    3. After creating both files, run the TypeScript compiler to confirm no type errors:
       ```bash
       npx tsc --noEmit
       ```
       Fix any type errors before completing this task. Common issue: if `@/lib/supabase` path alias is not configured in tsconfig, use the relative path `../lib/supabase` from submitAudit's perspective or verify the existing codebase uses `@/` aliases (check other src/lib files for import patterns).

    4. Run the production build to confirm the bundle succeeds:
       ```bash
       npm run build
       ```
  </action>
  <verify>
    1. `src/lib/supabase.ts` exists and exports `supabase`
    2. `src/lib/submitAudit.ts` exists and exports `submitAudit`
    3. `submitAudit` function signature accepts `(formState: AuditFormState, scores: AuditScores)` and returns `Promise<string>`
    4. `submitAudit.ts` chains `.select('id').single()` on the insert
    5. `npx tsc --noEmit` exits with code 0
    6. `npm run build` exits with code 0
  </verify>
  <done>
    src/lib/supabase.ts exports the singleton. src/lib/submitAudit.ts exports the typed insert function returning a UUID string. TypeScript compilation passes. Build succeeds. No service role key or secret appears in any source file or environment template.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npm run build` exits 0 — no TypeScript or bundler errors
2. Grep confirms only `src/vite-env.d.ts` and `src/lib/supabase.ts` reference `VITE_SUPABASE` in src/
3. No `service_role`, `sb_secret_`, or JWT service role token appears in src/ or .env.example
4. `.env.example` has exactly two variable name lines with empty values
5. `.env` does not exist or is not tracked by git
</verification>

<success_criteria>
- @supabase/supabase-js installed and listed in package.json dependencies
- src/lib/supabase.ts: createClient singleton with fail-fast env var check, exported as `supabase`
- src/lib/submitAudit.ts: maps AuditFormState + AuditScores to table columns, chains .select('id').single(), returns UUID string
- .env.example: two lines with empty values, committed to git
- src/vite-env.d.ts: ImportMetaEnv typed for exactly the two allowed VITE_ variables
- TypeScript build passes with no errors, no secret keys in any source file
</success_criteria>

<output>
After completion, create `.planning/phases/01-schema-and-environment/01-02-SUMMARY.md` using the summary template. Include: @supabase/supabase-js version installed, files created (supabase.ts, submitAudit.ts, .env.example, vite-env.d.ts), the column mapping from AuditFormState to audits table columns, and confirmation that TypeScript build passes.
</output>
