---
phase: 05-frontend-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/pages/Loading.tsx
autonomous: true
requirements:
  - DATA-03

must_haves:
  truths:
    - "Loading.tsx calls submitAudit first, then invokes generate-report edge function with the returned auditId"
    - "The loading screen waits for BOTH the minimum animation timer (~8s) AND the generate-report response before redirecting"
    - "A 429 rate limit response blocks the user on the loading screen with a time-hint message and no navigation"
    - "A non-429 error shows a Retry button that re-calls only generate-report (not submitAudit again)"
    - "Clicking 'Skip to Report' after an error navigates to the report page with template-generated content as fallback"
  artifacts:
    - path: "src/pages/Loading.tsx"
      provides: "Refactored loading screen with generate-report invocation, rate limit handling, and retry logic"
      contains: "functions.invoke"
  key_links:
    - from: "src/pages/Loading.tsx"
      to: "supabase/functions/generate-report/index.ts"
      via: "supabase.functions.invoke('generate-report')"
      pattern: "functions\\.invoke.*generate-report"
    - from: "src/pages/Loading.tsx"
      to: "src/lib/submitAudit.ts"
      via: "submitAudit(formState, scores)"
      pattern: "submitAudit"
---

<objective>
Refactor Loading.tsx to call the generate-report edge function during the loading screen, with rate limit handling, error retry, and minimum animation timer.

Purpose: Currently Loading.tsx only calls submitAudit (fire-and-forget) and uses a hard 14.5s setTimeout for redirect. This plan makes the loading screen actually drive AI report generation, properly handle 429 rate limits and errors, and redirect only when both the API and minimum timer complete.

Output: Fully wired Loading.tsx that orchestrates submitAudit -> generate-report -> navigate
</objective>

<execution_context>
@C:/Users/Emil/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Emil/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/pages/Loading.tsx (current implementation â€” must be refactored)
@src/lib/submitAudit.ts (returns Promise<string> with the auditId)
@src/lib/supabase.ts (supabase client singleton)
@supabase/functions/generate-report/index.ts (response shapes: success â†’ { success: true, report: {...} }, rate limit â†’ { rateLimited: true, message: "..." }, error â†’ { success: false, error: "..." })
@.planning/phases/05-frontend-integration/05-CONTEXT.md (locked decisions)
@.planning/phases/05-frontend-integration/05-RESEARCH.md (patterns and pitfalls)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor Loading.tsx async orchestration and error handling</name>
  <files>src/pages/Loading.tsx</files>
  <action>
Refactor the entire Loading.tsx component. Keep the existing visual design (logo, spinner, progress bar, step labels) but replace the async logic entirely.

**State additions:**
- `isRateLimited: boolean` â€” true when 429 received; shows block message
- `rateLimitMessage: string` â€” the message from the 429 body (includes time hint)
- `aiError: string | null` â€” non-null when generate-report fails (non-429)
- `aiReport: Record<string, unknown> | null` â€” store the AI report data to pass to Report via nav state
- Keep existing `auditIdRef` â€” stores auditId from first submitAudit call to prevent duplicate rows on retry

**Import additions:**
- `import { supabase } from '@/lib/supabase'`
- `import { FunctionsHttpError } from '@supabase/supabase-js'`
- `import type { AIReportData } from '@/types/audit'`

**Async orchestration (replace the existing useEffect body after validation):**

```
const MIN_WAIT_MS = 8000;

async function runAuditFlow() {
  const startTime = Date.now();

  // Step 1: Submit audit to DB (must complete first â€” auditId needed for generate-report)
  try {
    const id = await submitAudit(formState, scores);
    auditIdRef.current = id;
  } catch (err) {
    setError(`Failed to save audit: ${(err as Error).message}`);
    // Use fallback ID
    auditIdRef.current = locationState?.auditId || 'demo-' + Date.now();
  }

  // Step 2: Fire generate-report + remaining min timer in parallel
  await callGenerateReport(startTime);
}

async function callGenerateReport(startTime: number) {
  const auditId = auditIdRef.current;
  if (!auditId || auditId.startsWith('demo-')) {
    // submitAudit failed â€” skip AI, go to report with template content
    const elapsed = Date.now() - startTime;
    await new Promise(r => setTimeout(r, Math.max(0, MIN_WAIT_MS - elapsed)));
    navigate(`/report/${auditId}`, { state: { formState, scores, auditId } });
    return;
  }

  const elapsed = Date.now() - startTime;
  const remaining = Math.max(0, MIN_WAIT_MS - elapsed);
  const minTimer = new Promise<void>(r => setTimeout(r, remaining));

  try {
    const generateCall = supabase.functions.invoke('generate-report', {
      body: { auditId, formState, scores },
    });

    const [result] = await Promise.all([generateCall, minTimer]);
    const { data, error } = result;

    if (error instanceof FunctionsHttpError) {
      const body = await error.context.json();
      if (body?.rateLimited) {
        setIsRateLimited(true);
        setRateLimitMessage(body.message);
        return; // Stay on loading screen â€” do NOT navigate
      }
      throw error; // Non-429 HTTP error
    }

    if (error || !data?.success) {
      throw new Error(error?.message || data?.error || 'Report generation failed');
    }

    // Success â€” navigate to report with AI data
    navigate(`/report/${auditId}`, {
      state: { formState, scores, auditId, aiReport: data.report },
    });

  } catch (err) {
    setAiError((err as Error).message || 'Report generation failed');
    // Show Retry button â€” user can retry or skip to template report
  }
}
```

Store `callGenerateReport` start time in a ref so retry can use it.

**Retry handler:**
```
function handleRetry() {
  setAiError(null);
  callGenerateReport(Date.now()); // No min timer on retry â€” user already waited
}
```

**Skip to report (give up on AI):**
```
function handleSkipToReport() {
  const auditId = auditIdRef.current || 'demo-' + Date.now();
  navigate(`/report/${auditId}`, { state: { formState, scores, auditId } });
}
```

**Remove:**
- The hard `setTimeout(14500)` redirect
- The fire-and-forget `submitAudit().then/.catch` pattern
- The `redirect` timeout variable

**Keep:**
- The `stepInterval` (decorative step cycling every 1800ms) â€” this runs independently of real API work per locked decision
- The `progressInterval` (progress bar) â€” keep as visual engagement, but adjust timing: instead of 140ms per 1%, use a rate that reaches ~90% at 8s (8000/90 â‰ˆ 89ms per tick), then pause at 90% until API resolves
- The logo, spinner, step labels visual design

**UI additions for rate limit state:**
When `isRateLimited` is true, replace the progress bar and step list with:
```jsx
<div className="w-full max-w-md text-center">
  <div className="mb-4 text-4xl">ðŸš«</div>
  <h2 className="text-xl font-bold text-white mb-3">Too Many Submissions</h2>
  <p className="text-white/70 mb-6">{rateLimitMessage}</p>
  <p className="text-white/40 text-sm">Your audit data has been saved. You'll receive your report once the limit resets.</p>
</div>
```
Per locked decision: "Do NOT show a report link or template fallback on rate limit â€” just the block message."

**UI additions for AI error state:**
When `aiError` is not null, show below the progress bar:
```jsx
<div className="w-full max-w-md space-y-3">
  <div className="p-4 bg-red-500/20 border border-red-500/50 rounded-lg">
    <p className="text-red-200 text-sm text-center mb-3">Report generation encountered an issue.</p>
    <div className="flex gap-3 justify-center">
      <button
        onClick={handleRetry}
        className="px-4 py-2 rounded-lg text-white font-medium text-sm"
        style={{ backgroundColor: "hsl(var(--coral))" }}
      >
        Retry
      </button>
      <button
        onClick={handleSkipToReport}
        className="px-4 py-2 rounded-lg text-white/70 hover:text-white font-medium text-sm border border-white/20 hover:border-white/40"
      >
        Skip to Report
      </button>
    </div>
  </div>
</div>
```
Per locked decision: "If the user gives up on retry, continue to the report page with template-generated content as fallback."

**Progress bar adjustment:**
Pause progress at 90% until the API resolves. On success, jump to 100%. On error, pause at current value.

**Cleanup:**
The useEffect cleanup should clear `stepInterval` and `progressInterval`. The async flow is not cancellable via simple clearTimeout since it uses await â€” instead, use a `mounted` ref:
```
const mountedRef = useRef(true);
useEffect(() => { mountedRef.current = true; /* ... */ return () => { mountedRef.current = false; }; }, []);
```
Check `mountedRef.current` before any `set*` calls or `navigate()` calls in the async flow.
  </action>
  <verify>
- `npm run build` passes without errors
- Loading.tsx imports supabase and FunctionsHttpError
- Loading.tsx calls `supabase.functions.invoke('generate-report', ...)` with auditId, formState, scores
- Loading.tsx checks for `FunctionsHttpError` and reads `body.rateLimited` for 429 handling
- Retry button calls generate-report only (not submitAudit)
- Skip button navigates to report without aiReport in state
- No hard setTimeout redirect exists
- The decorative step labels still cycle
  </verify>
  <done>
- Loading.tsx orchestrates submitAudit -> generate-report with Promise.all + minTimer
- 429 rate limit blocks user on loading screen with message and no navigation
- Non-429 errors show Retry + Skip buttons
- Retry only re-invokes generate-report (preserving auditIdRef, no duplicate rows)
- Skip navigates to report with template-only content (no aiReport in state)
- Decorative steps and progress bar run during real API work
- The old 14.5s hard redirect is removed
  </done>
</task>

</tasks>

<verification>
1. Loading.tsx calls generate-report edge function and passes auditId, formState, scores in the body
2. Rate limit (429) state shows block message without navigation
3. Error state shows Retry and Skip buttons
4. Retry calls only generate-report (no submitAudit re-call)
5. Navigation to report includes aiReport in location state when AI succeeds
6. Navigation to report omits aiReport when user skips (template fallback path)
7. `npm run build` passes
</verification>

<success_criteria>
- Loading.tsx fully orchestrates the audit submission and AI report generation flow
- Rate limiting activates automatically on real user traffic (Phase 4 guard now enforced)
- Error handling covers both 429 and non-429 failures with appropriate UX per locked decisions
- The decorative loading animation continues during real API work
</success_criteria>

<output>
After completion, create `.planning/phases/05-frontend-integration/05-02-SUMMARY.md`
</output>
