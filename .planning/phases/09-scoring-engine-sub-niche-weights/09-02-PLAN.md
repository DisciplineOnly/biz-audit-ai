---
phase: 09-scoring-engine-sub-niche-weights
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - supabase/functions/generate-report/index.ts
autonomous: true
requirements:
  - SCORE-01

must_haves:
  truths:
    - "buildPrompt() receives a subNiche parameter and includes it in the user prompt"
    - "The AI prompt includes a line like 'Sub-Niche: HVAC' when a sub-niche is provided"
    - "The AI prompt does NOT include sub-niche when subNiche is null or undefined"
    - "The Deno.serve handler reads subNiche from the request body and passes it to buildPrompt()"
    - "The sub-niche label (human-readable) is used in the prompt, not the config key"
    - "No weight context is sent to the AI — only the sub-niche name"
    - "npm run build succeeds with zero errors (frontend only — edge function verified manually)"
  artifacts:
    - path: "supabase/functions/generate-report/index.ts"
      provides: "Sub-niche context in AI prompt for more specific recommendations"
      contains: "subNiche"
  key_links:
    - from: "supabase/functions/generate-report/index.ts"
      to: "src/config/subNicheConfig.ts"
      via: "Sub-niche label lookup concept (not direct import — edge function is Deno)"
      pattern: "subNiche"
---

<objective>
Add sub-niche context to the AI report generation prompt so Claude Haiku 4.5 can produce recommendations specific to the user's business type (e.g., "as an HVAC business" rather than generic "home services business").

Purpose: The Phase 9 context explicitly states "Pass sub-niche name to the AI report prompt — sub-niche name only, no weight context in the prompt. Let the AI's own knowledge drive recommendations." This makes AI-generated reports feel more personalized to the specific sub-niche without leaking scoring internals.
Output: AI report prompt includes sub-niche name when available, producing more specific recommendations.
</objective>

<execution_context>
@C:/Users/Emil/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Emil/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-scoring-engine-sub-niche-weights/09-CONTEXT.md
@supabase/functions/generate-report/index.ts
@src/config/subNicheConfig.ts
@src/pages/Loading.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add subNiche to buildPrompt parameters and user prompt</name>
  <files>
    supabase/functions/generate-report/index.ts
  </files>
  <action>
1. Update the `buildPrompt()` function parameters to include `subNiche`:

   ```typescript
   function buildPrompt(params: {
     niche: string
     businessName: string
     scores: AuditScores
     formState: FormState
     techFrustrations: string
     biggestChallenge: string
     subNiche?: string | null  // NEW — human-readable sub-niche label
   }): { system: string; user: string } {
     const { niche, businessName, scores, formState, techFrustrations, biggestChallenge, subNiche } = params
   ```

2. In the `user` prompt string (around line 317), add a sub-niche line after the `Niche:` line. Only include it when subNiche is provided:

   Find:
   ```
   Business: ${businessName}
   Niche: ${nicheLabel}
   Overall Score: ${overallScore}/100
   ```

   Replace with:
   ```
   Business: ${businessName}
   Niche: ${nicheLabel}
   ${subNiche ? `Sub-Niche: ${subNiche}` : ''}
   Overall Score: ${overallScore}/100
   ```

3. Also add a brief instruction to the system prompt about sub-niche specificity. Find the end of the system prompt (after the JSON output instruction) and add before the closing backtick:

   Add after the existing `Constraints:` block (after the CTA bullet):
   ```
   - When a sub-niche is specified, tailor recommendations to that specific business type (e.g., "as a plumbing business" not just "home services"). Use your knowledge of that sub-niche's unique challenges and opportunities.
   ```
  </action>
  <verify>
- The edge function file has no syntax errors (manual review — cannot run Deno build locally)
- buildPrompt includes subNiche in its parameter type
- The user prompt includes "Sub-Niche: X" when subNiche is provided
- The user prompt does NOT include a "Sub-Niche:" line when subNiche is null/undefined
- The system prompt instructs Claude to tailor recommendations to the sub-niche
- No scoring weights or weight context appears in the prompt
  </verify>
  <done>buildPrompt() accepts optional subNiche parameter. User prompt includes "Sub-Niche: {label}" when provided. System prompt instructs Claude to tailor to the specific sub-niche type.</done>
</task>

<task type="auto">
  <name>Task 2: Read subNiche from request body and pass to buildPrompt</name>
  <files>
    supabase/functions/generate-report/index.ts
  </files>
  <action>
1. In the main `Deno.serve` handler, after the existing `const niche = formState?.niche || 'home_services'` line (around line 436), add a sub-niche label lookup:

   ```typescript
   const niche = formState?.niche || 'home_services'

   // Sub-niche: read from request body, resolve to human-readable label
   const subNicheKey: string | null = body.subNiche ?? null
   ```

2. Create a simple label lookup map inside the handler (we cannot import from the frontend config in a Deno edge function). Place this above or near the `buildPrompt` call:

   ```typescript
   // Sub-niche display labels — must stay in sync with SUB_NICHE_REGISTRY in src/config/subNicheConfig.ts
   const SUB_NICHE_LABELS: Record<string, string> = {
     hvac: 'HVAC', plumbing: 'Plumbing', electrical: 'Electrical', garage_doors: 'Garage Doors',
     pest_control: 'Pest Control', landscaping: 'Landscaping', cleaning: 'Cleaning',
     roofing: 'Roofing', painting: 'Painting', general_contracting: 'General Contracting',
     construction: 'Construction', interior_design: 'Interior Design',
     residential_sales: 'Residential Sales', commercial: 'Commercial / Office',
     property_management: 'Property Management', new_construction: 'New Construction',
     luxury_resort: 'Luxury / Resort',
   }
   const subNicheLabel = subNicheKey ? (SUB_NICHE_LABELS[subNicheKey] ?? null) : null
   ```

3. Update the `buildPrompt()` call to pass the sub-niche label:

   ```typescript
   const { system, user } = buildPrompt({
     niche,
     businessName,
     scores,
     formState,
     techFrustrations,
     biggestChallenge,
     subNiche: subNicheLabel,  // NEW
   })
   ```

4. **Important**: The frontend (`Loading.tsx`) must also pass `subNiche` in the request body. Check if `Loading.tsx` already sends the full formState (which includes `subNiche`). If it does, the edge function can read `body.formState.subNiche` instead of `body.subNiche`. Verify which field name to use and update accordingly.

   If `Loading.tsx` sends `formState` but NOT a separate `subNiche` field, update the edge function to read from `body.formState?.subNiche ?? body.subNiche ?? null` for maximum compatibility:

   ```typescript
   const subNicheKey: string | null = body.subNiche ?? body.formState?.subNiche ?? null
   ```

   **Do NOT modify Loading.tsx in this plan** — the formState already contains subNiche from Phase 8. The edge function should read it from wherever it exists in the request body.
  </action>
  <verify>
- The edge function reads subNiche from the request body (checking both body.subNiche and body.formState.subNiche)
- SUB_NICHE_LABELS map covers all 17 sub-niches
- The label lookup handles null/undefined subNiche gracefully
- buildPrompt receives the human-readable label, not the config key
- No Deno-specific syntax errors (manual review)
  </verify>
  <done>Edge function reads subNiche from request body, resolves to human-readable label via inline lookup map, passes label to buildPrompt(). FormState interface in the edge function does NOT need updating — subNiche is read from the top-level body or formState.</done>
</task>

<task type="auto">
  <name>Task 3: Add subNiche to FormState interface in edge function</name>
  <files>
    supabase/functions/generate-report/index.ts
  </files>
  <action>
1. Update the `FormState` interface in the edge function to include `subNiche`. This ensures type safety when reading `body.formState.subNiche`. Find the `FormState` interface (around line 54):

   ```typescript
   interface FormState {
     niche: string
     subNiche?: string | null  // NEW — sub-niche key from AuditFormState
     step1: {
   ```

2. This is a minor type addition — no behavioral change, just ensures the interface reflects what the frontend actually sends.
  </action>
  <verify>
- FormState interface includes `subNiche?: string | null`
- No other changes to the interface
  </verify>
  <done>FormState interface in edge function updated to include subNiche field for type safety.</done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors (frontend)
2. `supabase/functions/generate-report/index.ts` has no syntax errors (manual review)
3. `buildPrompt()` accepts `subNiche` parameter
4. When subNiche is "hvac", the user prompt includes "Sub-Niche: HVAC"
5. When subNiche is null, no "Sub-Niche:" line appears in the prompt
6. System prompt includes sub-niche tailoring instruction
7. SUB_NICHE_LABELS covers all 17 sub-niches
8. FormState interface includes subNiche field
9. No scoring weights or weight context is leaked to the AI prompt
</verification>

<success_criteria>
- AI prompt includes sub-niche name for personalized recommendations
- No weight context in prompt — AI uses its own knowledge (per 09-CONTEXT decision)
- Human-readable label used (not config key) — "HVAC" not "hvac"
- Graceful fallback when no sub-niche — prompt is identical to v1.0
- Edge function reads subNiche from formState (which already includes it from Phase 8)
- SUB_NICHE_LABELS map stays in sync with SUB_NICHE_REGISTRY (documented with comment)
</success_criteria>

<output>
After completion, create `.planning/phases/09-scoring-engine-sub-niche-weights/09-02-SUMMARY.md`
</output>
