---
phase: 09-scoring-engine-sub-niche-weights
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/config/subNicheConfig.ts
  - src/lib/scoring.ts
  - src/pages/AuditForm.tsx
autonomous: true
requirements:
  - SCORE-01
  - SCORE-02
  - SCORE-03

must_haves:
  truths:
    - "A SubNicheWeights type exists defining per-category weight overrides"
    - "SUB_NICHE_WEIGHTS config maps SubNicheGroup keys to weight override objects"
    - "Every weight override object's values sum to exactly 1.0"
    - "Groups with no meaningful weight differences have no entry in SUB_NICHE_WEIGHTS (graceful fallback to base weights)"
    - "computeScores() accepts an optional subNiche parameter"
    - "When subNiche is null or undefined, computeScores() produces identical results to v1.0 (base weights unchanged)"
    - "When subNiche is provided, computeScores() applies the config-defined weight overrides via getSubNicheGroup lookup"
    - "The CategoryScore weight field in the returned categories array reflects the applied weights (not always the base weights)"
    - "AuditForm.tsx passes state.subNiche to computeScores()"
    - "npm run build succeeds with zero errors"
  artifacts:
    - path: "src/config/subNicheConfig.ts"
      provides: "SubNicheWeights type, SUB_NICHE_WEIGHTS config, getWeightsForSubNiche() helper"
      contains: "SUB_NICHE_WEIGHTS"
    - path: "src/lib/scoring.ts"
      provides: "computeScores() with optional subNiche parameter and weight override logic"
      contains: "getWeightsForSubNiche"
    - path: "src/pages/AuditForm.tsx"
      provides: "Passes state.subNiche to computeScores()"
      contains: "computeScores(state"
  key_links:
    - from: "src/lib/scoring.ts"
      to: "src/config/subNicheConfig.ts"
      via: "getWeightsForSubNiche() import"
      pattern: "getWeightsForSubNiche"
    - from: "src/pages/AuditForm.tsx"
      to: "src/lib/scoring.ts"
      via: "computeScores() call with subNiche argument"
      pattern: "computeScores"
---

<objective>
Add config-driven weight overrides to the scoring engine per sub-niche group. Define research-based weight distributions in subNicheConfig.ts, integrate weight override lookup into computeScores(), and wire the sub-niche through from AuditForm.

Purpose: Different sub-niches have meaningfully different business priorities. A pest control company's success depends more on follow-up and retention (service agreements) than an HVAC shop's, while a construction firm's operations and financial controls matter more than for a residential cleaning service. This plan makes scoring reflect those real-world differences.
Output: computeScores() applies sub-niche-aware weights when a sub-niche is selected, produces identical v1.0 results when none is selected.
</objective>

<execution_context>
@C:/Users/Emil/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Emil/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-scoring-engine-sub-niche-weights/09-CONTEXT.md
@.planning/research/FEATURES.md
@.planning/research/ARCHITECTURE.md
@src/lib/scoring.ts
@src/config/subNicheConfig.ts
@src/types/audit.ts
@src/pages/AuditForm.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define SubNicheWeights type and research-driven weight config</name>
  <files>
    src/config/subNicheConfig.ts
  </files>
  <action>
1. Add the weight override type and config to `src/config/subNicheConfig.ts`. Place these after the existing `SUB_NICHE_OPTIONS` config and helper functions.

   ```typescript
   /**
    * Weight overrides for scoring categories per sub-niche group.
    * All 7 values must sum to 1.0. Only groups with meaningfully
    * different priorities from the base weights get an entry.
    *
    * Base weights (used when no sub-niche or no override exists):
    *   technology: 0.10, leads: 0.20, scheduling: 0.15,
    *   communication: 0.10, followUp: 0.15, operations: 0.15, financial: 0.15
    */
   export interface SubNicheWeights {
     technology: number;
     leads: number;
     scheduling: number;
     communication: number;
     followUp: number;
     operations: number;
     financial: number;
   }
   ```

2. Define the `SUB_NICHE_WEIGHTS` config. Research-driven rationale for each group:

   **HS Reactive (HVAC, Plumbing, Electrical, Garage Doors):**
   Emergency-driven businesses. Lead response speed and scheduling/dispatch are critical differentiators. A missed call is a lost $500-$5000 job. Scheduling efficiency directly impacts revenue capacity. Technology and follow-up are still important but less differentiating than for recurring services.
   - leads: 0.20 (same — lead response is critical), scheduling: 0.20 (+5 — dispatch efficiency is a core competitive advantage), operations: 0.15 (same), followUp: 0.10 (-5 — less recurring relationship), communication: 0.10 (same), technology: 0.10 (same), financial: 0.15 (same)

   **HS Recurring (Pest Control, Landscaping, Cleaning):**
   Subscription/contract-based businesses. Customer retention and service agreements drive recurring revenue. Follow-up and retention is the primary growth lever — a lost customer represents months/years of recurring revenue. Lead acquisition matters less than keeping existing customers on recurring plans.
   - leads: 0.15 (-5 — growth comes from retention more than new leads), scheduling: 0.15 (same — route efficiency matters), followUp: 0.20 (+5 — service agreements and retention are the business model), operations: 0.15 (same), communication: 0.10 (same), technology: 0.10 (same), financial: 0.15 (same)

   **HS Project-Based (Roofing, Painting, GC, Construction, Interior Design):**
   High-value, low-frequency projects. Financial controls (job costing, estimates, margins) and operations (project management, quality control) are the primary success drivers. Lead generation still matters but is more about closing high-value estimates than volume. Scheduling is less critical than project management discipline.
   - leads: 0.15 (-5 — fewer, higher-value leads), scheduling: 0.10 (-5 — project timelines, not daily dispatch), operations: 0.20 (+5 — project management and QC are critical), financial: 0.20 (+5 — job costing and margins define profitability), followUp: 0.15 (same), communication: 0.10 (same), technology: 0.10 (same)

   **RE Residential Sales:**
   The closest to the base weight profile. Lead generation and conversion are the primary drivers. This is the "default" RE profile that the base weights were designed around.
   - No override needed — use base weights.

   **RE Commercial / Office:**
   Long deal cycles (6-18 months), relationship-driven. Lead management (nurture) matters more than volume. Operations (transaction management, accountability) are critical for complex multi-party deals. Financial tracking of pipeline and deal economics is essential.
   - leads: 0.15 (-5 — fewer deals, longer cycles), scheduling: 0.20 (+5 — lead management/nurture is critical for long cycles), operations: 0.20 (+5 — complex transaction management), financial: 0.15 (same), followUp: 0.10 (-5 — less post-close volume), communication: 0.10 (same), technology: 0.10 (same)

   **RE Property Management:**
   Operational excellence business. Communication (tenant relations), operations (maintenance, occupancy), and financial controls (rent collection, NOI) are the core competencies. Lead generation is about owner acquisition, not tenant volume.
   - leads: 0.10 (-10 — owner acquisition is low-volume), scheduling: 0.10 (-5 — tenant management, not lead nurture), operations: 0.20 (+5 — maintenance, compliance, occupancy), financial: 0.20 (+5 — rent collection, NOI, owner reporting), communication: 0.15 (+5 — tenant communication is core), followUp: 0.15 (same), technology: 0.10 (same)

   **RE New Construction:**
   Sales-pipeline focused with presale reservation management. Lead management (nurture through long build cycles) is critical. Financial tracking of unit economics matters. Operations are builder-managed, less team-driven.
   - leads: 0.20 (same — presale pipeline is critical), scheduling: 0.20 (+5 — long nurture through build cycle), followUp: 0.15 (same), financial: 0.15 (same), operations: 0.10 (-5 — builder handles operations), communication: 0.10 (same), technology: 0.10 (same)

   **RE Luxury / Resort:**
   Relationship-intensive, high-touch sales. Communication and follow-up with high-net-worth clients are the primary differentiators. Lead generation is referral-driven, not volume-driven. Financial operations matter for high-value commission tracking.
   - leads: 0.15 (-5 — referral-driven, not volume), scheduling: 0.10 (-5 — fewer deals, manual touch), communication: 0.15 (+5 — white-glove client experience), followUp: 0.20 (+5 — relationship maintenance drives referrals), operations: 0.10 (-5 — small team, less process-driven), financial: 0.15 (same), technology: 0.15 (+5 — marketing/presentation tech matters)

   ```typescript
   /**
    * Research-driven weight overrides per sub-niche group.
    * Only groups with meaningfully different priorities from base weights are listed.
    * Unlisted groups (e.g., residential_sales) use the base weights in scoring.ts.
    */
   export const SUB_NICHE_WEIGHTS: Partial<Record<SubNicheGroup, SubNicheWeights>> = {
     // HS Reactive: emergency-driven — scheduling/dispatch is the core competitive advantage
     reactive: {
       technology: 0.10, leads: 0.20, scheduling: 0.20,
       communication: 0.10, followUp: 0.10, operations: 0.15, financial: 0.15,
     },

     // HS Recurring: subscription-based — retention and service agreements drive revenue
     recurring: {
       technology: 0.10, leads: 0.15, scheduling: 0.15,
       communication: 0.10, followUp: 0.20, operations: 0.15, financial: 0.15,
     },

     // HS Project-Based: high-value projects — financial controls and operations define profitability
     project_based: {
       technology: 0.10, leads: 0.15, scheduling: 0.10,
       communication: 0.10, followUp: 0.15, operations: 0.20, financial: 0.20,
     },

     // RE Commercial: long deal cycles — lead nurture and transaction management are critical
     commercial: {
       technology: 0.10, leads: 0.15, scheduling: 0.20,
       communication: 0.10, followUp: 0.10, operations: 0.20, financial: 0.15,
     },

     // RE Property Management: operational excellence — communication, operations, financial controls
     property_management: {
       technology: 0.10, leads: 0.10, scheduling: 0.10,
       communication: 0.15, followUp: 0.15, operations: 0.20, financial: 0.20,
     },

     // RE New Construction: presale pipeline — long nurture through build cycle
     new_construction: {
       technology: 0.10, leads: 0.20, scheduling: 0.20,
       communication: 0.10, followUp: 0.15, operations: 0.10, financial: 0.15,
     },

     // RE Luxury/Resort: relationship-intensive — communication, follow-up, and presentation tech
     luxury_resort: {
       technology: 0.15, leads: 0.15, scheduling: 0.10,
       communication: 0.15, followUp: 0.20, operations: 0.10, financial: 0.15,
     },
   };
   // NOTE: residential_sales intentionally omitted — base weights are a good fit
   ```

3. Add a helper function below the config:

   ```typescript
   /** Get scoring weights for a sub-niche, falling back to null if no overrides exist */
   export function getWeightsForSubNiche(subNiche: SubNiche | null): SubNicheWeights | null {
     if (!subNiche) return null;
     const group = getSubNicheGroup(subNiche);
     return SUB_NICHE_WEIGHTS[group] ?? null;
   }
   ```

4. Verify that every `SubNicheWeights` object's 7 values sum to exactly 1.0 (manually check each entry).
  </action>
  <verify>
- `npm run build` succeeds
- `SubNicheWeights` type is exported
- `SUB_NICHE_WEIGHTS` has entries for 7 of 8 groups (residential_sales excluded)
- Each weight object has exactly 7 keys: technology, leads, scheduling, communication, followUp, operations, financial
- Each weight object's values sum to 1.0
- `getWeightsForSubNiche()` is exported and returns null for null input and for residential_sales
- `getWeightsForSubNiche("hvac")` returns the reactive weights
- `getWeightsForSubNiche("residential_sales")` returns null
  </verify>
  <done>SubNicheWeights type, research-driven SUB_NICHE_WEIGHTS config for 7 groups (reactive, recurring, project_based, commercial, property_management, new_construction, luxury_resort), and getWeightsForSubNiche() helper added to subNicheConfig.ts. residential_sales uses base weights by design.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate weight overrides into computeScores()</name>
  <files>
    src/lib/scoring.ts
    src/pages/AuditForm.tsx
  </files>
  <action>
1. In `src/lib/scoring.ts`, import the helper:

   ```typescript
   import { getWeightsForSubNiche } from "@/config/subNicheConfig";
   import type { SubNiche } from "@/types/audit";
   ```

2. Update the `computeScores()` function signature to accept an optional `subNiche` parameter:

   ```typescript
   export function computeScores(state: AuditFormState, subNiche?: SubNiche | null): AuditScores {
   ```

3. Replace the hardcoded `weights` object with sub-niche-aware weight resolution. Find the existing `weights` const (currently at the end of the function, around line 514):

   ```typescript
   // Old:
   const weights = {
     technology: 0.1,
     leads: 0.2,
     scheduling: 0.15,
     communication: 0.1,
     followUp: 0.15,
     operations: 0.15,
     financial: 0.15,
   };
   ```

   Replace with:

   ```typescript
   // Base weights — used when no sub-niche or no override exists
   const baseWeights = {
     technology: 0.10,
     leads: 0.20,
     scheduling: 0.15,
     communication: 0.10,
     followUp: 0.15,
     operations: 0.15,
     financial: 0.15,
   };

   // Apply sub-niche weight overrides when available
   const subNicheWeights = getWeightsForSubNiche(subNiche ?? null);
   const weights = subNicheWeights ?? baseWeights;
   ```

4. Update the `categories` array to use the actual applied weights (not always base weights). The existing code uses hardcoded `weight: 10`, `weight: 20`, etc. Update these to derive from the applied `weights`:

   ```typescript
   const categories: CategoryScore[] = [
     { category: "technology", label: "Technology & Software", score: technology, weight: Math.round(weights.technology * 100) },
     { category: "leads", label: "Lead Funnel & Marketing", score: leads, weight: Math.round(weights.leads * 100) },
     { category: "scheduling", label: schedulingLabel, score: scheduling, weight: Math.round(weights.scheduling * 100) },
     { category: "communication", label: "Communication", score: communication, weight: Math.round(weights.communication * 100) },
     { category: "followUp", label: "Follow-Up & Retention", score: followUp, weight: Math.round(weights.followUp * 100) },
     { category: "operations", label: "Operations & Accountability", score: operations, weight: Math.round(weights.operations * 100) },
     { category: "financial", label: "Financial Operations", score: financial, weight: Math.round(weights.financial * 100) },
   ];
   ```

5. In `src/pages/AuditForm.tsx`, find the `computeScores(state)` call (around line 119) and update it to pass the sub-niche:

   ```typescript
   // Old:
   const scores = computeScores(state);

   // New:
   const scores = computeScores(state, state.subNiche);
   ```
  </action>
  <verify>
- `npm run build` succeeds
- `computeScores` signature accepts optional `subNiche` parameter
- Calling `computeScores(state)` without subNiche (existing API) still works and uses base weights
- Calling `computeScores(state, "hvac")` applies reactive weights
- Calling `computeScores(state, "residential_sales")` uses base weights (no override)
- The `categories` array weight field reflects the applied weights
- AuditForm.tsx passes `state.subNiche` to `computeScores()`
  </verify>
  <done>computeScores() now accepts optional subNiche parameter and applies config-driven weight overrides. AuditForm.tsx passes state.subNiche to computeScores(). CategoryScore weight field reflects applied weights. Backward compatible — no subNiche = base weights.</done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors
2. `npm run test` passes (no existing tests broken)
3. `SubNicheWeights` type is exported from `src/config/subNicheConfig.ts`
4. `SUB_NICHE_WEIGHTS` config has 7 entries, each with 7 keys summing to 1.0
5. `getWeightsForSubNiche(null)` returns null
6. `getWeightsForSubNiche("hvac")` returns reactive weights (scheduling: 0.20)
7. `getWeightsForSubNiche("residential_sales")` returns null (base weights)
8. `computeScores(state)` without subNiche produces base-weight results
9. `computeScores(state, "plumbing")` produces different overall score than `computeScores(state)` when category scores differ
10. `AuditForm.tsx` passes `state.subNiche` to `computeScores()`
</verification>

<success_criteria>
- Base weights unchanged when no sub-niche is selected (SCORE-01 regression safety)
- Sub-niche weight overrides apply when subNiche is provided (SCORE-01)
- All weight overrides sum to 1.0 (mathematical correctness)
- Config-driven approach — no hardcoded conditionals in scoring.ts (SCORE-03)
- Language has zero involvement in scoring logic (SCORE-02 by architectural guarantee)
- Helper function abstracts group lookup — computeScores never needs to know about HS grouping
</success_criteria>

<output>
After completion, create `.planning/phases/09-scoring-engine-sub-niche-weights/09-01-SUMMARY.md`
</output>
