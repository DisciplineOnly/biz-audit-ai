---
phase: 03-email-webhook
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/YYYYMMDDHHMMSS_add_email_status_and_audit_reports.sql
  - supabase/functions/generate-report/index.ts
autonomous: true
requirements: [EMAIL-01]

must_haves:
  truths:
    - "The audits table has an email_status column with values pending/sent/failed"
    - "An audit_reports table exists storing AI-generated report content keyed by audit_id"
    - "The generate-report edge function inserts the AI report JSON into audit_reports after successful generation"
  artifacts:
    - path: "supabase/migrations/YYYYMMDDHHMMSS_add_email_status_and_audit_reports.sql"
      provides: "email_status column on audits + audit_reports table"
      contains: "email_status"
    - path: "supabase/functions/generate-report/index.ts"
      provides: "Updated generate-report that writes to audit_reports"
      contains: "audit_reports"
  key_links:
    - from: "supabase/functions/generate-report/index.ts"
      to: "audit_reports table"
      via: "supabaseAdmin.from('audit_reports').insert()"
      pattern: "audit_reports.*insert"
---

<objective>
Create the database foundation for Phase 3 email notifications: add email_status tracking to audits, create a new audit_reports table to store AI-generated report content, and update the generate-report edge function to persist AI reports into the new table.

Purpose: The send-notification edge function (Plan 02) needs to read AI report content from the database to include recommendations in the admin email. Currently, generate-report returns the AI report to the client but does not persist it. This plan closes that gap and adds the email_status column the notification system will update.

Output: One migration SQL file, one updated edge function file.
</objective>

<execution_context>
@C:/Users/Emil/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Emil/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-email-webhook/03-RESEARCH.md
@.planning/phases/02-ai-report-edge-function/02-01-SUMMARY.md
@supabase/migrations/20260219055745_create_audits_table.sql
@supabase/migrations/20260219120000_add_report_status_to_audits.sql
@supabase/functions/generate-report/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migration — add email_status column and create audit_reports table</name>
  <files>supabase/migrations/YYYYMMDDHHMMSS_add_email_status_and_audit_reports.sql</files>
  <action>
Create a single migration file. Use a timestamp-based filename following the existing pattern (YYYYMMDDHHMMSS format, e.g., 20260220120000).

The migration must do two things:

1. Add email_status column to the audits table:
```sql
ALTER TABLE public.audits
  ADD COLUMN email_status TEXT NOT NULL DEFAULT 'pending'
    CHECK (email_status IN ('pending', 'sent', 'failed'));
```
Per user decision: only 'pending', 'sent', 'failed' — NO 'partial' value (since only admin email is sent in this phase).

2. Create the audit_reports table to store AI-generated report content:
```sql
CREATE TABLE public.audit_reports (
  id         UUID        PRIMARY KEY DEFAULT gen_random_uuid(),
  audit_id   UUID        NOT NULL REFERENCES public.audits(id) ON DELETE CASCADE,
  report     JSONB       NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(audit_id)
);
```

The `report` JSONB column stores the full AI report object (executiveSummary, gaps, quickWins, strategicRecommendations).
The UNIQUE constraint on audit_id ensures one report per audit.
ON DELETE CASCADE ensures cleanup if an audit row is ever deleted.

3. Enable RLS on audit_reports (following CVE-2025-48757 precedent from Phase 1 — always enable RLS at creation):
```sql
ALTER TABLE public.audit_reports ENABLE ROW LEVEL SECURITY;
```

4. Add a service_role-only policy so the edge function (using service_role key) can read/write, but anon cannot:
```sql
-- No policies for anon = zero access (same pattern as audits table)
-- Service role bypasses RLS automatically — no explicit policy needed
```
Actually, do NOT create any RLS policies. Service role bypasses RLS by default. No anon access = no anon policies. This matches the audits table pattern exactly.

Do NOT add a SELECT policy for anon on audit_reports — this data is read only by edge functions using service_role.
  </action>
  <verify>
Verify the SQL file exists and contains: email_status column ALTER, audit_reports CREATE TABLE, RLS ENABLE, and the correct CHECK constraint values (pending, sent, failed only — no 'partial').

Run: `grep -c "email_status\|audit_reports\|ROW LEVEL SECURITY" supabase/migrations/*email_status*` should return 3+ matches.

Note: Migration application to remote DB requires MCP or Dashboard SQL editor (same pattern as Phase 1 and 2 — executor lacks MCP access).
  </verify>
  <done>Migration SQL file exists with email_status column (pending/sent/failed), audit_reports table with JSONB report column, UNIQUE(audit_id) constraint, RLS enabled, and no anon policies.</done>
</task>

<task type="auto">
  <name>Task 2: Update generate-report to persist AI report into audit_reports table</name>
  <files>supabase/functions/generate-report/index.ts</files>
  <action>
Modify the existing generate-report edge function to INSERT the parsed AI report JSON into the audit_reports table after successful generation, BEFORE updating report_status to 'completed'.

The insertion order matters: audit_reports INSERT must happen BEFORE report_status UPDATE. This ensures the AI report content is available in the database when the Database Webhook fires on the status change to 'completed'. If the INSERT happens after the UPDATE, the send-notification function could fire and find no report data.

In the success path of the Deno.serve handler (after `reportData = JSON.parse(responseText)` succeeds), add:

```typescript
// Persist AI report for email notifications and future retrieval
await supabaseAdmin
  .from('audit_reports')
  .upsert({
    audit_id: auditId,
    report: reportData,
  }, { onConflict: 'audit_id' })
```

Use `.upsert()` with `onConflict: 'audit_id'` instead of `.insert()` to handle edge cases where the function might be retried (idempotent). If a report already exists for this audit_id, it gets replaced.

Place this BEFORE the existing `report_status: 'completed'` update line. The sequence must be:
1. Parse AI response into reportData
2. Upsert reportData into audit_reports
3. Update report_status to 'completed' (this triggers the webhook)

Do NOT modify the error/failure path. If AI generation fails, report_status goes to 'failed' and no audit_report row is created — this is correct behavior.

Do NOT modify the CORS handling, sanitization, prompt building, or response format. Only add the upsert call.

Do NOT add the audit_reports upsert to the catch block's best-effort 'failed' status update — there is no report to store on failure.
  </action>
  <verify>
1. Read the updated generate-report/index.ts and confirm:
   - `audit_reports` appears in the file
   - The upsert call is BEFORE the `report_status: 'completed'` update
   - The upsert uses `onConflict: 'audit_id'`
   - No other changes were made to the function logic

2. Run: `npm run build` to confirm no TypeScript compilation errors in the main app (the edge function is Deno, not built by Vite, but this confirms we didn't accidentally break imports).
  </verify>
  <done>generate-report edge function upserts AI report JSON into audit_reports table before updating report_status to 'completed'. The upsert is idempotent via onConflict. Error path is unchanged.</done>
</task>

</tasks>

<verification>
- Migration SQL file contains email_status ALTER with CHECK (pending, sent, failed)
- Migration SQL file contains CREATE TABLE audit_reports with JSONB report column and UNIQUE(audit_id)
- Migration SQL file enables RLS on audit_reports
- generate-report/index.ts contains audit_reports upsert before report_status update
- No other files modified
</verification>

<success_criteria>
- email_status column migration is ready to apply (pending/sent/failed values only)
- audit_reports table migration is ready to apply (stores full AI report JSON)
- generate-report function persists report data before triggering the status change that fires the webhook
- All changes are backward-compatible: generate-report still returns the same response to callers
</success_criteria>

<output>
After completion, create `.planning/phases/03-email-webhook/03-01-SUMMARY.md`
</output>
