---
phase: 05-frontend-integration
plan: 03
type: execute
wave: 2
depends_on:
  - 05-01
  - 05-02
files_modified:
  - src/pages/Report.tsx
autonomous: true
requirements:
  - DATA-03

must_haves:
  truths:
    - "Opening /report/:uuid via a shareable URL (no localStorage, no navigation state) loads the full report from Supabase"
    - "A skeleton layout is shown while the report is being fetched"
    - "If the AI report is still pending (report_status='pending'), the page polls every 4 seconds and shows a generating message"
    - "After 90 seconds of polling with no resolution, a timeout message is shown instead of infinite spinning"
    - "A non-existent UUID shows a branded 404 page with a 'Start a New Audit' CTA"
    - "AI-generated content (gaps, quick wins, strategic recommendations, executive summary) renders using the same visual components as template content"
    - "When AI content is unavailable (null), the page falls back to template-generated content from generateMockReport()"
  artifacts:
    - path: "src/pages/Report.tsx"
      provides: "Dual data source report page: navigation state OR Supabase fetch with polling, skeleton, 404, and AI content rendering"
      contains: "useQuery"
  key_links:
    - from: "src/pages/Report.tsx"
      to: "src/lib/fetchReport.ts"
      via: "fetchReport(auditId) in useQuery queryFn"
      pattern: "fetchReport"
    - from: "src/pages/Report.tsx"
      to: "src/lib/scoring.ts"
      via: "generateMockReport fallback when aiReport is null"
      pattern: "generateMockReport"
---

<objective>
Refactor Report.tsx to support dual data sources (navigation state fast path and Supabase fetch slow path), render AI-generated content, show skeleton loading, poll for pending reports, and display a branded 404 for invalid UUIDs.

Purpose: This is the core DATA-03 requirement — shareable report URLs must work without localStorage or navigation state. This plan wires Report.tsx to the fetch-report edge function (Plan 01) and renders AI content from the generate-report response (passed via navigation state from Plan 02's Loading.tsx or fetched from Supabase).

Output: Report.tsx that works both as a post-submission redirect and as a standalone shareable URL
</objective>

<execution_context>
@C:/Users/Emil/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Emil/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-frontend-integration/05-01-SUMMARY.md (fetch-report edge function + fetchReport helper + AIReportData type)
@.planning/phases/05-frontend-integration/05-02-SUMMARY.md (Loading.tsx navigation state shape: { formState, scores, auditId, aiReport? })
@src/pages/Report.tsx (current implementation — needs refactoring)
@src/lib/fetchReport.ts (created in Plan 01)
@src/lib/scoring.ts (generateMockReport for fallback)
@src/types/audit.ts (AIReportData, AIReportItem types)
@src/components/ui/skeleton.tsx (Skeleton component)
@.planning/phases/05-frontend-integration/05-CONTEXT.md (locked decisions)
@.planning/phases/05-frontend-integration/05-RESEARCH.md (patterns: dual data source, polling, AI rendering)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dual data source with Supabase fetch, skeleton, polling, and 404</name>
  <files>src/pages/Report.tsx</files>
  <action>
Refactor the data loading logic in Report.tsx. Keep ALL existing visual components (ScoreBar, OverallScoreCircle, BenchmarkBadge) and report sections unchanged. Only modify the data loading and top-level conditional rendering.

**New imports:**
```typescript
import { useQuery } from '@tanstack/react-query';
import { fetchReport } from '@/lib/fetchReport';
import { Skeleton } from '@/components/ui/skeleton';
import type { AIReportData } from '@/types/audit';
```

**Replace the existing useEffect data loading with dual data source logic:**

1. **Navigation state detection (fast path):**
```typescript
const { auditId } = useParams();
const location = useLocation();
const navigate = useNavigate();

const locationState = location.state as {
  formState?: AuditFormState;
  scores?: AuditScores;
  auditId?: string;
  aiReport?: AIReportData;
} | null;

const hasNavigationState = !!(locationState?.formState && locationState?.scores);
```

2. **Supabase fetch (slow path) with useQuery:**
```typescript
const [pollStartTime] = useState(() => Date.now());
const POLL_TIMEOUT_MS = 90_000; // 90 seconds max polling

const {
  data: fetchedData,
  isLoading,
  isError,
  error: fetchError,
} = useQuery({
  queryKey: ['report', auditId],
  queryFn: () => fetchReport(auditId!),
  enabled: !hasNavigationState && !!auditId,
  retry: (failureCount, error) => {
    // Don't retry 404s
    if (error instanceof Error && error.message === 'not_found') return false;
    return failureCount < 2;
  },
  refetchInterval: (query) => {
    const data = query.state.data;
    if (!data) return false;
    if (data.reportStatus === 'pending') {
      // Stop polling after timeout
      if (Date.now() - pollStartTime > POLL_TIMEOUT_MS) return false;
      return 4000; // poll every 4s
    }
    return false; // stop when completed or failed
  },
  refetchIntervalInBackground: false,
});
```

3. **Unified data resolution:**
```typescript
// Resolve data from navigation state OR fetched data
const formState = locationState?.formState ?? fetchedData?.audit?.form_data ?? null;
const scores = locationState?.scores ?? fetchedData?.audit?.scores ?? null;
const aiReport: AIReportData | null = locationState?.aiReport ?? fetchedData?.aiReport ?? null;
const reportStatus = fetchedData?.reportStatus ?? (locationState?.aiReport ? 'completed' : null);
```

Remove the `useState` for `formState` and `scores` — they are now derived directly (no useEffect setting state). Remove the `STORAGE_KEY` constant and all localStorage reads. The shareable URL path now handles all non-navigation-state cases.

Also remove the `copied` useState — keep it, it's used by the Share button.

4. **Conditional rendering (insert before the main report JSX, in this order):**

**a. Loading/skeleton state (fetching from Supabase):**
When `!hasNavigationState && isLoading`:
```jsx
<div className="min-h-screen bg-background">
  {/* Header skeleton */}
  <div style={{ backgroundColor: "hsl(var(--navy))" }} className="py-4 px-6">
    <div className="max-w-5xl mx-auto flex items-center justify-between">
      <Skeleton className="h-7 w-32 bg-white/10" />
      <div className="flex gap-3">
        <Skeleton className="h-5 w-16 bg-white/10" />
        <Skeleton className="h-5 w-24 bg-white/10" />
      </div>
    </div>
  </div>
  {/* Hero skeleton */}
  <div style={{ backgroundColor: "hsl(var(--navy))" }} className="py-12 px-6">
    <div className="max-w-5xl mx-auto flex flex-col md:flex-row md:items-center md:justify-between gap-8">
      <div className="space-y-3">
        <Skeleton className="h-5 w-48 bg-white/10" />
        <Skeleton className="h-10 w-72 bg-white/10" />
        <Skeleton className="h-4 w-56 bg-white/10" />
        <div className="flex gap-2 mt-4">
          <Skeleton className="h-6 w-20 rounded-full bg-white/10" />
          <Skeleton className="h-6 w-24 rounded-full bg-white/10" />
        </div>
      </div>
      <Skeleton className="h-40 w-40 rounded-full bg-white/10 mx-auto md:mx-0" />
    </div>
  </div>
  {/* Content skeleton */}
  <div className="max-w-5xl mx-auto px-4 py-10 space-y-6">
    <Skeleton className="h-48 w-full rounded-2xl" />
    <Skeleton className="h-64 w-full rounded-2xl" />
    <Skeleton className="h-40 w-full rounded-2xl" />
    <Skeleton className="h-56 w-full rounded-2xl" />
  </div>
</div>
```

**b. Branded 404 (UUID not found):**
When `isError && fetchError instanceof Error && fetchError.message === 'not_found'`:
```jsx
<div className="min-h-screen flex flex-col items-center justify-center gap-6 px-6"
  style={{ backgroundColor: "hsl(var(--navy))" }}>
  <div className="w-10 h-10 rounded-xl flex items-center justify-center text-white font-bold"
    style={{ backgroundColor: "hsl(var(--coral))" }}>
    E&P
  </div>
  <h1 className="text-2xl font-bold text-white">Report Not Found</h1>
  <p className="text-white/60 text-center max-w-md">
    This audit link is invalid or has expired. Start a new audit to generate a fresh report.
  </p>
  <Link to="/" className="px-6 py-3 rounded-xl text-white font-semibold transition-all hover:opacity-90"
    style={{ backgroundColor: "hsl(var(--coral))" }}>
    Start a New Audit
  </Link>
</div>
```

**c. Fetch error (non-404):**
When `isError` and not a 404:
```jsx
<div className="min-h-screen flex flex-col items-center justify-center gap-4">
  <p className="text-muted-foreground">Failed to load report. Please try again.</p>
  <Link to="/" className="text-sm font-medium" style={{ color: "hsl(var(--coral))" }}>
    Start a New Audit →
  </Link>
</div>
```

**d. Report generating (pending state with polling):**
When `fetchedData?.reportStatus === 'pending'` and we're still within poll timeout:
```jsx
<div className="min-h-screen flex flex-col items-center justify-center gap-6 px-6"
  style={{ backgroundColor: "hsl(var(--navy))" }}>
  <div className="relative w-16 h-16">
    <div className="absolute inset-0 rounded-full border-4 border-white/10" />
    <div className="absolute inset-0 rounded-full border-4 border-transparent animate-spin"
      style={{ borderTopColor: "hsl(var(--coral))" }} />
  </div>
  <h2 className="text-xl font-bold text-white">Your Report is Being Generated...</h2>
  <p className="text-white/60 text-center max-w-md">
    Our AI is analyzing your audit responses. This usually takes 15–30 seconds.
  </p>
</div>
```

**e. Poll timeout (pending > 90s):**
When `fetchedData?.reportStatus === 'pending'` and `Date.now() - pollStartTime > POLL_TIMEOUT_MS`:
```jsx
<div className="min-h-screen flex flex-col items-center justify-center gap-6 px-6"
  style={{ backgroundColor: "hsl(var(--navy))" }}>
  <h2 className="text-xl font-bold text-white">Taking Longer Than Expected</h2>
  <p className="text-white/60 text-center max-w-md">
    Your report is still being generated. Try refreshing the page in a few minutes, or contact support if this persists.
  </p>
  <button onClick={() => window.location.reload()}
    className="px-6 py-3 rounded-xl text-white font-semibold transition-all hover:opacity-90"
    style={{ backgroundColor: "hsl(var(--coral))" }}>
    Refresh Page
  </button>
</div>
```

**f. No data available (neither navigation state nor successful fetch):**
When `!formState || !scores` — keep the existing "No report data found" fallback but update it to match branded 404 style.

Keep the render order: skeleton -> 404 -> fetch error -> pending -> poll timeout -> no data -> full report.
  </action>
  <verify>
- `npm run build` passes
- Report.tsx imports and uses `useQuery` from @tanstack/react-query
- Report.tsx imports and calls `fetchReport` from @/lib/fetchReport
- Report.tsx imports `Skeleton` from @/components/ui/skeleton
- The `localStorage` reads are removed (shareable URLs use Supabase fetch instead)
- Branded 404 rendered for 'not_found' errors
- Skeleton rendered during loading
- Polling with 4s interval for pending status with 90s timeout
  </verify>
  <done>
- Shareable URLs load full report from Supabase without localStorage or navigation state
- Skeleton UI shown while fetching
- Pending report status triggers polling with 90s timeout
- Branded 404 for invalid UUIDs
- Non-404 fetch errors show generic error message
  </done>
</task>

<task type="auto">
  <name>Task 2: Render AI-generated content with template fallback</name>
  <files>src/pages/Report.tsx</files>
  <action>
Modify the report rendering sections to use AI content when available, falling back to template content from `generateMockReport()`.

**AI content resolution (after data loading, before rendering sections):**
```typescript
// Generate template content as fallback
const templateReport = (formState && scores) ? generateMockReport(formState, scores) : null;

// Resolve which content to render — AI takes priority
const gaps = aiReport?.gaps ?? templateReport?.criticalGaps ?? [];
const quickWins = aiReport?.quickWins ?? templateReport?.quickWins ?? [];
const strategicRecs = aiReport?.strategicRecommendations ?? templateReport?.strategicRecs ?? [];
const executiveSummary = aiReport?.executiveSummary ?? null;
```

**Executive Summary section:**
When `executiveSummary` is present (AI report), replace the entire 4-paragraph template block with:
```jsx
<div className="prose prose-sm max-w-none text-muted-foreground leading-relaxed">
  <p>{executiveSummary}</p>
</div>
```

When `executiveSummary` is null (template fallback), render the existing 4-paragraph template JSX unchanged.

Use a simple conditional:
```jsx
{executiveSummary ? (
  <div className="prose prose-sm max-w-none text-muted-foreground leading-relaxed">
    <p>{executiveSummary}</p>
  </div>
) : (
  <div className="prose prose-sm max-w-none text-muted-foreground leading-relaxed space-y-3">
    {/* existing 4 paragraphs */}
  </div>
)}
```

**Critical Gaps section:**
Replace `criticalGaps.map(...)` with `gaps.map(...)`. The existing card JSX uses `gap.title`, `gap.description`, `gap.impact` — all of which exist in both template and AI shapes. No JSX changes needed, only the variable name.

**Quick Wins section:**
Replace `quickWins.map(...)` with the resolved `quickWins` variable. Same shape: `win.title`, `win.description`, `win.timeframe`. No JSX changes.

**Strategic Recommendations section:**
Replace `strategicRecs.map(...)` with the resolved `strategicRecs` variable. Same shape: `rec.title`, `rec.description`, `rec.roi`. No JSX changes.

**CTA field rendering (Claude's Discretion):**
The AI report items include a `cta` field. Render it as a subtle text line below the impact/timeframe/roi in each card, only when present:
```jsx
{('cta' in item && item.cta) && (
  <p className="text-xs mt-2" style={{ color: "hsl(var(--coral))" }}>
    {item.cta}
  </p>
)}
```

Add this to gaps cards (below the impact badge), quick wins items (below timeframe), and strategic rec cards (below ROI). This is lightweight — no button, just colored text. Consistent with the research recommendation.

**Competitor Benchmark section:**
No changes — this section uses `scores.categories` directly (client-side score-driven logic, no AI involvement per locked decision).

**isHS and businessName derivation:**
These are already derived from `formState`. For the Supabase fetch path where `formState` comes from `fetchedData.audit.form_data`, the shape is the same AuditFormState — `formState.niche` and `formState.step1.businessName` work identically.

**Remove:**
- The destructuring `const { criticalGaps, quickWins, strategicRecs } = generateMockReport(formState, scores);` — replaced by the conditional resolution above
- The `STORAGE_KEY` constant (already removed in Task 1, confirm removal)
  </action>
  <verify>
- `npm run build` passes
- When `aiReport` is present: executive summary shows AI text, gaps/wins/recs show AI content
- When `aiReport` is null: executive summary shows 4-paragraph template, gaps/wins/recs show template content
- CTA field renders as subtle coral-colored text below impact/timeframe/roi when present
- Competitor Benchmark section unchanged (still uses scores.categories)
- Template fallback uses `generateMockReport(formState, scores)` — same as before
  </verify>
  <done>
- AI-generated content renders in all report sections (executive summary, gaps, quick wins, strategic recommendations) when available
- Template content from generateMockReport() used as fallback when AI content is null
- CTA fields rendered as subtle text in each card
- Competitor Benchmark section unchanged (client-side scoring only)
- Visual consistency maintained — same card components for both AI and template content
  </done>
</task>

</tasks>

<verification>
1. Opening /report/:uuid directly (no navigation, no localStorage) shows a skeleton, then loads the full report from Supabase
2. Non-existent UUID shows branded 404 with "Start a New Audit" CTA
3. Pending report_status triggers polling every 4s with a "generating" message
4. After 90s of pending, shows timeout message with refresh button
5. AI content renders in all sections when available; template content used as fallback
6. Executive summary switches between AI single paragraph and template 4-paragraph block
7. Competitor Benchmark section unchanged (score-driven, no AI)
8. `npm run build` passes without errors
9. `npm run lint` passes
</verification>

<success_criteria>
- DATA-03 satisfied: shareable /report/:uuid URLs load from Supabase and display the full report
- Dual data source works: navigation state (fast path from Loading.tsx) and Supabase fetch (shareable URL path) both render the same report
- AI content renders when available, template content as fallback
- All edge cases handled: skeleton loading, branded 404, pending polling with timeout, fetch errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-frontend-integration/05-03-SUMMARY.md`
</output>
