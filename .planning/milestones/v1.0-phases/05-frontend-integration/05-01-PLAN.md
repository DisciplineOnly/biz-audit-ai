---
phase: 05-frontend-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/functions/fetch-report/index.ts
  - src/lib/fetchReport.ts
  - src/types/audit.ts
autonomous: true
requirements:
  - DATA-03

must_haves:
  truths:
    - "A POST to the fetch-report edge function with a valid auditId returns the audit row and AI report data"
    - "A POST with a non-existent auditId returns a 404 JSON response"
    - "The fetchReport client helper wraps supabase.functions.invoke and returns typed data"
  artifacts:
    - path: "supabase/functions/fetch-report/index.ts"
      provides: "Edge function that reads audits + audit_reports with service_role"
      contains: "SUPABASE_SERVICE_ROLE_KEY"
    - path: "src/lib/fetchReport.ts"
      provides: "Client-side helper to call fetch-report edge function"
      exports: ["fetchReport", "FetchReportResult"]
    - path: "src/types/audit.ts"
      provides: "AIReportData type definition for AI report JSON shape"
      contains: "AIReportData"
  key_links:
    - from: "src/lib/fetchReport.ts"
      to: "supabase/functions/fetch-report/index.ts"
      via: "supabase.functions.invoke('fetch-report')"
      pattern: "functions\\.invoke.*fetch-report"
    - from: "supabase/functions/fetch-report/index.ts"
      to: "audits + audit_reports tables"
      via: "service_role Supabase client"
      pattern: "SUPABASE_SERVICE_ROLE_KEY"
---

<objective>
Create the fetch-report edge function and client helper that enables shareable report URLs to load audit data from Supabase.

Purpose: The audits table has no anon SELECT policy (SEC-02). A service_role edge function is needed to read audit data for shareable URLs. This also creates the typed client helper and AI report type definitions used by Report.tsx in Plan 03.

Output: Deployed fetch-report edge function, fetchReport.ts client helper, AIReportData type
</objective>

<execution_context>
@C:/Users/Emil/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Emil/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@supabase/functions/generate-report/index.ts (pattern reference — per_worker instantiation, corsHeaders import, JSON response shape)
@supabase/functions/_shared/cors.ts
@src/lib/submitAudit.ts (pattern reference — supabase client usage)
@src/lib/supabase.ts
@src/types/audit.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create fetch-report edge function and AIReportData type</name>
  <files>
    supabase/functions/fetch-report/index.ts
    src/types/audit.ts
  </files>
  <action>
**1. Add AIReportData type to src/types/audit.ts:**

Append to the end of the file (after all existing types/exports):

```typescript
/** Shape returned by the generate-report edge function's AI response */
export interface AIReportItem {
  title: string;
  description: string;
  impact?: string;
  timeframe?: string;
  roi?: string;
  priority: 'high' | 'medium' | 'low';
  cta: string;
}

export interface AIReportData {
  executiveSummary: string;
  gaps: AIReportItem[];
  quickWins: AIReportItem[];
  strategicRecommendations: AIReportItem[];
}
```

**2. Create supabase/functions/fetch-report/index.ts:**

Follow the exact pattern from generate-report/index.ts:
- Import `corsHeaders` from `'../_shared/cors.ts'`
- Import `createClient` from `'npm:@supabase/supabase-js@2'`
- Import edge runtime types: `import 'jsr:@supabase/functions-js/edge-runtime.d.ts'`
- Handle OPTIONS for CORS preflight
- Accept POST with `{ auditId }` body (consistent with generate-report pattern)
- Instantiate supabaseAdmin INSIDE handler (per_worker mode — same as generate-report)
- Query `audits` table: `select('id, niche, business_name, form_data, scores, report_status, created_at').eq('id', auditId).single()`
- If audit not found (error or null), return 404 with `{ error: 'not_found' }`
- Query `audit_reports` table: `select('report').eq('audit_id', auditId).single()`
- Return 200 with `{ audit, aiReport: reportRow?.report ?? null, reportStatus: audit.report_status }`
- Wrap in try/catch, return 500 on unexpected errors
- All responses include `{ ...corsHeaders, 'Content-Type': 'application/json' }` headers

Do NOT add rate limiting to this function — it's a read-only endpoint for viewing already-generated reports.
  </action>
  <verify>
- `npx tsc --noEmit` passes (type check on src/types/audit.ts changes)
- `supabase/functions/fetch-report/index.ts` file exists and follows the same pattern as generate-report
- AIReportData type is exported from src/types/audit.ts
  </verify>
  <done>
- fetch-report edge function exists at supabase/functions/fetch-report/index.ts with service_role reads from audits + audit_reports
- AIReportData and AIReportItem interfaces are exported from src/types/audit.ts
- 404 response for missing auditId, 200 with combined data for valid auditId
  </done>
</task>

<task type="auto">
  <name>Task 2: Create fetchReport client helper and deploy edge function</name>
  <files>
    src/lib/fetchReport.ts
  </files>
  <action>
**1. Create src/lib/fetchReport.ts:**

```typescript
import { supabase } from '@/lib/supabase';
import { FunctionsHttpError } from '@supabase/supabase-js';
import type { AuditFormState, AuditScores, AIReportData } from '@/types/audit';

export interface FetchReportResult {
  audit: {
    id: string;
    niche: string;
    business_name: string;
    form_data: AuditFormState;
    scores: AuditScores;
    report_status: 'pending' | 'completed' | 'failed';
    created_at: string;
  };
  aiReport: AIReportData | null;
  reportStatus: 'pending' | 'completed' | 'failed';
}

export async function fetchReport(auditId: string): Promise<FetchReportResult> {
  const { data, error } = await supabase.functions.invoke('fetch-report', {
    body: { auditId },
  });

  if (error) {
    if (error instanceof FunctionsHttpError) {
      // 404 — audit not found
      const errorBody = await error.context.json();
      if (errorBody?.error === 'not_found') {
        throw new Error('not_found');
      }
    }
    throw new Error(error.message || 'Failed to fetch report');
  }

  return data as FetchReportResult;
}
```

Key points:
- Uses `supabase.functions.invoke` (not raw fetch) — automatically adds apikey + auth headers
- Distinguishes 404 (not_found) from other errors by reading FunctionsHttpError body
- Throws `new Error('not_found')` for 404 so Report.tsx can show branded 404 page
- Returns typed FetchReportResult matching the fetch-report edge function response shape

**2. Deploy fetch-report edge function via Supabase MCP:**

The executor should deploy the edge function using the Supabase MCP `deploy_edge_function` tool. When deploying via MCP, the function source must be inlined (MCP cannot resolve `../_shared/cors.ts` imports). Inline the `corsHeaders` constant directly in the function source — same pattern used when deploying generate-report in Phase 2 (see STATE.md decision: "generate-report MCP deploy inlines corsHeaders constant").

Keep the local file at `supabase/functions/fetch-report/index.ts` with the shared import (`from '../_shared/cors.ts'`) for CLI deploy compatibility.
  </action>
  <verify>
- `npx tsc --noEmit` passes
- `src/lib/fetchReport.ts` exports `fetchReport` function and `FetchReportResult` interface
- Edge function deployed and reachable (verify via MCP or note for executor)
  </verify>
  <done>
- fetchReport.ts client helper created with typed FetchReportResult
- fetch-report edge function deployed to Supabase
- Client helper correctly handles 404 (throws 'not_found') and other errors
  </done>
</task>

</tasks>

<verification>
1. AIReportData type is exported from src/types/audit.ts and matches the generate-report JSON schema (executiveSummary, gaps, quickWins, strategicRecommendations)
2. fetch-report edge function reads from both audits and audit_reports tables using service_role
3. fetchReport client helper returns typed data and handles 404 vs other errors
4. No anon SELECT policies added (SEC-02 preserved)
5. `npm run build` passes without errors
</verification>

<success_criteria>
- fetch-report edge function deployed and returns combined audit + AI report data for valid UUIDs
- fetchReport client helper available for Report.tsx to import in Plan 03
- AIReportData type available for both Loading.tsx (Plan 02) and Report.tsx (Plan 03)
- No new security surface — reads happen through service_role edge function only
</success_criteria>

<output>
After completion, create `.planning/phases/05-frontend-integration/05-01-SUMMARY.md`
</output>
